(ns basifangs.utils
  (:import socket)
  (:require [clojure.string :as str]))

(defn tee [x]
  (println x)
  x)

(def flag-chars
  "Ideally these would be ordered by the how commonly used they are in flags"
  ;; Some chars are placed at the end of the list as they tend to interfere.
  ;; CHAR | EXAMPLE
  ;; %    | LIKE "<prefix>%"
  ;; .    | regex
  ;; *    | regex
  ;; +    | regex
  ;; #    | interpeted as a comment in some injection contexts
  
  "-_{}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"$&'(),/:;<=>?@[\\]^`|~%.*+#")

(def flag-chars-no-regex-specials "-_{}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&'(),/:;<=>?@[\\]^`|~")

(defn recvall [sock]
  (let [s (loop [s ""
                 suffix (-> sock
                            (.recv 4096)
                            (.decode "utf-8"))]
            (if (= suffix "")
              s
              (recur (str s suffix)
                     (-> sock
                         (.recv 4096)
                         (.decode "utf-8")))))]
    (.close sock)
    (def recvallout s)
    s))

(defn quick-tcp
  "string in, string out tcp"
  [host port msg]
  (let [sock (socket/socket #_ip socket/AF_INET #_tcp socket/SOCK_STREAM)]
    (.settimeout sock 5.0)
    (.connect sock #py(host port))
    (.sendall sock (.encode msg "utf-8"))
    (recvall sock)))

(defn char-by-char 
  "In many challenges you achieve a fn checking if the flag starts with
  a given prefix. This fn captures the logic to go from such a fn, to
  the flag in an efficient manner."
  ([starts-with?]
   (char-by-char starts-with? ""))
  
  ([starts-with? prefix]
   (char-by-char starts-with? prefix {:chars flag-chars
                                      :max-length 100}))
  
  ([starts-with?
    prefix
    {:as opts
     :keys [chars]}]
   (if (>= (count new-prefix) max-length)
     ;; Sometimes we get false positives. E.g a regex prefix is
     ;; evolving like so:
     ;;
     ;; 1. fjdkal.
     ;; 2. fjdkal..
     ;; 3. fjdkal...
     ;; n. fjdkal...........................
     ;;
     ;; We don't want to accidentally DOS any servers so we
     ;; automatically quit after a while.
     (println "Prefix hit :max-length. Stopping search.")
     (let [new-prefix 
           (binding [*pmap-cpu-count* (count chars)]
             (->> chars
                  (pmap (comp (juxt identity starts-with?) (partial str prefix)))
                  (map (fn [[new-prefix match?]]
                         (println [new-prefix match?])
                         (when match? new-prefix)))
                  (filter identity)
                  first))]
       (if-not new-prefix
         (println "No new prefix found. Stopping search.")
         (do (println "New prefix:" new-prefix)
             (char-by-char starts-with? new-prefix opts)))))))
